# useEffect × 非同期の設計判断

- 課題 ID：FE-20260101-001
- 課題難易度：中級

## 課題内容

以下を満たす 最小構成の React + TS コンポーネント を作る。

### 要件

- ボタンを押すと fetch を実行
- ローディング状態を管理
- エラーを握りつぶさない
- useEffect を使うパターンで実装する

### 制限（重要）

- useCallback / useMemo 使用禁止
- ライブラリ禁止（SWR / React Query なし）
- 「とりあえず動く」より 判断理由を重視

### 提出物

- コンポーネントコード

### 評価観点

- 実装がシンプルか
- useEffect を「副作用の置き場」として扱えているか
- 無駄な抽象化をしていないか

---

## 補足説明

> なぜ イベントハンドラ直書き fetch ではなくuseEffect + state トリガーにしたか

これは副作用か？それともイベント処理か？

『イベントハンドラ直書き fetch の問題』

```jsx
const handleClick = async () => {
  const res = await fetch(...)
  setData(...)
}
```

- コンポーネントのライフサイクルと切り離される
  - アンマウント後にsetStateされる危険性
- cleanup / abort の置き場がない
- 再実行条件がクリックに固定される
- 非同期状態（loading / error）が肥大化しがち

『seEffect + state トリガー』

`setExecuteFetch(true) ` useEffectが反応

- 非同期処理を 副作用として隔離
- cleanup を Reactのライフサイクルに乗せられる
- 「何が起きたら fetch するか」を 依存配列で宣言的に書ける
- 再実行・中断・初期化の制御が可能

> この実装で起きうる問題点

『executeFetch が「使い捨てトリガー」になっている』

```jsx
setExecuteFetch(true)
...
finally {
  setExecuteFetch(false)
}
```

- 何が微妙か
  - fetch を boolean トリガーで表現している
  - 「fetch したい理由」が state に残らない
  - 将来こうなると破綻しやすい
    - 引数付き fetch
    - 条件付き再取得
    - ポーリング / 再試行
  - state が “命令” になってるのが違和感ポイント

『useEffect が UI 制御まで抱えている』

```jsx
setLoading(true)
setError(null)
setData(...)
setExecuteFetch(false)
```

- 問題点
  - 非同期制御
  - エラーハンドリング
  - UI state 初期化
  - を全部やっている
- 結果
  - テストしづらい
  - 再利用できない
  - 他コンポーネントに横展開不可

『地味だけど実務で効く』

AbortController を 毎回 effect 内で生成・破棄しているため、

- fetch 以外の非同期（timeout / websocket）に拡張しづらい
- 「この component は何を中断できるのか」が見えない

> それを解消するとしたら「ref を使う」、「Custom Hook に切り出す」のどちらを選ぶか

このケースは Custom Hook 一択

『ref を使い続ける選択肢は「応急処置」』

- ref でできること：
  - 多重実行防止
  - AbortController 保持
  - フラグ管理
- でも…
  - ロジックが component に居座る
  - 他画面で再利用できない
  - テスト不能

「設計の伸び代を殺す」

『Custom Hook を選ぶ理由（実務判断）』

- このロジックは明確に：
  - UI ではない
  - 副作用制御
  - 非同期の状態機械
    - つまり `useFetch(url, options)` に切るべき責務

- Custom Hook にすると得られるもの
  - fetch / abort / loading / error を完全分離
  - component は「表示」に集中
  - 将来
    - SWR 風
    - 再試行
    - キャッシュ
    - に拡張可能
