# 「useRef × useEffect」で“前回値”を扱えるようにする

- 課題 ID：FE-20251229-003
- 難易度：初中級（25〜35分）

## 課題内容

useRef を使って 「前回の値」 を保持し、useEffect 内で 変化を検知・言語化 する課題。

### 要件

1. コンポーネント仕様
   - コンポーネント名：PreviousValueTracker
   - state `const [count, setCount] = useState(0)`
   - ref `const prevCountRef = useRef<number | null>(null)`
2. UI
   - 表示
     - 現在の count
     - 前回の count
   - 操作
     - 「+1」ボタン
     - 「-1」ボタン
3. 副作用ロジック
   - count が変更されたときにのみ useEffect を実行
   - 初回レンダー時は何もしない
   - 2回目以降で以下を console 出力
     - `console.log(`count: ${prev} → ${current}`)`
     - prev は前回値、current は現在値
4. 実装ルール（重要）
   - 前回値の保持は useRef のみ
   - state を使って前回値を保存しない
   - effect の最後で ref を更新する

### 思考ヒント

- 初回は「前回」が存在しない
- useEffect は「変更後」に呼ばれる
- ref は「次回のための記録」

### 確認ポイント

- 初回レンダーでログは出ていないか
- +1 / -1 どちらも正しく差分が出ているか
- ref の更新タイミングは effect の最後か

### 提出物

- コンポーネントコード
- なぜ ref 更新を effect の最後に置くのか
- これを state でやると何が起きるか

### この課題の狙い

- 前回スクロール位置
- 前回 props との差分検知
- アニメーションのトリガー
- API 再フェッチ条件制御
- 無限ループ回避

---

## 提出物の問いへの解答

> なぜ ref 更新を effect の最後に置くのか

useEffectは値が変わった後に実行されるため、effect冒頭で前回レンダー時点の値を参照して、
最後にrefを更新することで、今回の値を保存する。

> これを state でやると何が起きるか

setPrevCount(count)を呼ぶと再レンダーが走る。
差分を取るためのstate更新が、それ自体で副作用の原因になる。
