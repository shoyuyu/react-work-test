# useEffect を分ける：関心ごとごとに副作用を整理する

- 課題 ID：FE-20251229-001
- 難易度：初級〜初中級（25〜30分）

## 課題内容

1つのコンポーネント内で
役割の違う useEffect を「意図的に分ける」 課題。

### 要件

1. コンポーネント仕様
   - コンポーネント名：SeparatedEffects
   - state:
     - `const [count, setCount] = useState(0)`
     - `const [text, setText] = useState('')`
   - ref:
     - `const isFirstRenderRef = useRef(true)`
2. UI
   - 表示
     - count
     - text
   - 操作
     - 「+1」ボタン
     - input（text入力）
3. 副作用要件（重要）
   - A. count 用 effect
     - count が 変更されたときだけ 実行
     - 初回レンダーでは実行しない
     - 実行内容
       - `console.log('count changed:', count)`
   - B. text 用 effect
     - text が変更されたときだけ実行
     - 初回レンダーでは実行しない
     - 実行内容
       - `console.log('text changed:', text)`
4. 実装ルール（かなり重要）
   - useEffect は 2つ以上に分ける
   - 1つの effect に count と text を混ぜない
   - 初回スキップ判定は useRef を使う
   - state でフラグ管理しない

### 実装ヒント（思考の順番）

- 「何がトリガーで動くか」を先に決める
- effect = 1関心ごと1つ
- ref は「状態」ではなく「記憶」

### 提出物

- コンポーネントのコード
- なぜ effect を分けた方が良いのか
- 1つにまとめると何が起きるか

### この課題の狙い（実務直結）

- useEffect を「とりあえず1個」から卒業
- 依存配列の事故を防げる
- 読める・壊れにくいコンポーネントになる

これは

- バグ調査
- 仕様追加
- 将来の自分

全部を助ける。

---

## 提出物の問いへの解答

> なぜ effect を分けた方が良いのか

副作用の目的が異なるから 分ける事で、それぞれの責務が明確になり、バグが起きにくくなり、保守性が高くなる。

> 1つにまとめると何が起きるか

- 依存配列に[count, text] 両方を入れると、どちらか一方が変わっただけでもeffectが実行されてしまう
- 責務分離が曖昧になってしまい、結果不要な動作が走ってしまう
- 初回スキップ判定も複雑になり、バグの温床になる

なお、このコードは致命的なバグが存在している。

課題通りisFirstRenderRefを使用しているが、
isFirstRenderRef.currentを両方のeffectでfalseにしているため、
最初にどちらかのeffectが実行された時点で「初回判定」が解除され、もう一方のeffectも初回をスキップできなくなる。
