# 非同期 × useEffect：cleanup がないと何が起きるかを体感する

- 課題 ID：FE-20251230-001
- 難易度：初中級（10〜15分）

## 課題内容

setTimeout を使った擬似的な非同期処理を
useEffect で実行し、cleanup の役割を理解する。

### 要件

1. コンポーネント仕様
   - コンポーネント名：AsyncEffectBasic
   - state `const [count, setCount] = useState(0)`
2. UI
   - 表示: count
   - 操作: 「+1」ボタン
3. useEffect の処理内容
   - count が変更されたら effect 実行
   - effect 内で setTimeout を使う

```jsx
setTimeout(() => {
  console.log('async finished:', count)
}, 1000)
```

4. 実装ルール（重要）
   - 今日は cleanup を書かない
   - effect は count 依存
   - console.log で挙動を観察するだけでOK

### 観察ポイント（ここが本題）

- 連続で「+1」を押したらconsole に何が出る？
- ログの順番は回のための記録」直感通り？
- なぜ「古い count」がログに出る？

### 提出物

- コンポーネントコード
- 「何が危険か」
- 「なぜこうなるか」

### この課題の狙い

- useEffect の非同期は「あとから実行される」
- state は「その時点のスナップショット」
- cleanup がないと 古い処理が生き残る

---

## 提出物の問いへの解答

> 連続で「+1」を押したらconsole に何が出る？

ボタンを押した1秒後に「async finished: {n}」が順番に表示される。

> ログの順番は直感寄り？
> なぜ「古いcount」がログに出る？

setTimeoutを理解している場合は直感的ではあると思う。
ただし一般的には直感的ではない。
何故なら、連続でボタンを押すと「古いcount値」を持ったsetTimeoutが複数同時に動いて、1秒後に順番に古い値が表示されてしまうため。

> 何が危険か？

- 古い非同期処理が残り、古い値を持ったsetTimeoutが全て実行されてしまう
- 例えば、古い処理が残ると意図しない挙動やバグに繋がってしまう

> なぜこうなるのか？

setTimeoutのクロージャがeffect実行時の値を保持するため。
