# useRef：再レンダーしない値と「前回の state」を保持する

- 課題 ID：FE-20251228-002
- 難易度：初級〜初中級（20分前後）

## 課題内容

useRef を使って
「前回の値」と「今回の値」を比較する 課題。
useState ではなく useRef で保持する理由を体感する。

### 要件

1. コンポーネント仕様
   - コンポーネント名：PreviousValueCheck
   - state: `const [count, setCount] = useState(0)`
   - ref: `const prevCountRef = useRef<number | null>(null)`
2. UI
   - 表示
     - 現在の count
     - 前回の count
   - ボタン
     - 「+1」
     - 「-1」
3. 振る舞い要件（重要）
   - count が更新されたあとに、prevCountRef.current に 更新前の count を入れる
   - 初回レンダーでは前回の値は null or -- 表示でOK
   - prevCountRef の更新で再レンダーは起こさない

### 実装ヒント（方向性のみ）

- useEffect を使って「count が変わったあと」のタイミングを掴む
- prevCountRef.current = count の 位置が超重要
- 「なぜ render 中に書かないか」を意識する

### 提出物

- コンポーネントのコード
- なぜ prevCount を useState ではなく useRef で持つのか

### この課題の狙い

- useRef は
  - 値を保持できる
  - でも render を起こさない
- useEffect は「変更後」に動く
- この2つの組み合わせで
  - 差分検知
  - 前回値保持
  - 初回除外ができる

---

## 提出物の問いへの解答

> なぜ prevCount を useState ではなく useRef で持つのか

useRefは値が変わっても再レンダーを引き起こさないため useStateは、値が変わるたびに再レンダーが走る。
